package edu.cesspool.control_works

// КОНТРОЛЬНАЯ НА УРОВЕНЬ ЗНАНИЙ ОТ chatGPT

/*
* 1. Выведет 6
* 2. Выведет 7, 5, 7
*
* */

fun main(){
    //val myList = listOf<Int>(1,2,3,4,5,62,7,8,7,6,4,-100)
    //println(maxOrNull(myList))

//    val Petya = User("Petya Pumpkin", 14)
//    val Nadya = User("Nadezda Pedrovna",55)
//
//    println(Petya.isAdult())
//    println(Nadya.isAdult())
}



/*3*/
/*ВЕРНЕТ МАКСИМАЛЬНОЕ ЧИСЛО ИЛИ NULL*/
fun maxOrNull(list: List<Int>): Int? {
    if (list.size == 0){
        println("Список пуст")
        return null
    }

    var max = list[0]

    for (i in 0 until list.size){
        if (list[i] > max) max = list[i]
    }

    return max
}

/*4*/
/*дата-класс с функцией расширения*/
data class User(val name: String, val age: Int)
fun User.isAdult(): Boolean {
    return age > 17
}

/*5*/
/*
* ViewModel как я понимаю это компонент который выступает наверное в качестве некоторой прокладки между непосредственными
*  gui элементами и какой-то бизнес логикой приложения
* */


/*6 К сожалению у меня нет решения для 6 задания*/
/*на 7 задание вообще не дам ответа, если StateFlow еще где-то видел, то про LiveData вообще слышу впервые*/

/*8*/
/*Мои познания в репозиториях ужасны. Это именно та тема, которую я штурмую достаточно давно. Но в целом конечно
* я понимаю, что репозиторий это описание того, что должен УМЕТЬ делать класс (объект класса) (под уметь  я
* понимаю различные методы), и возможно (опционально) какими полями должен обладать класс, чтобы соответствовать
* данному репозиторию.
*
* Например есть класс автомобилей как репозиторий и у него должно быть свойство описывающее его количество колес и
* конечно же автомобиль должен уметь ездить. И вот например у нас есть классы седан, внедорожник, грузовик и если
* он умеет ездить и у него есть поле о количестве колес, то мы можем его где-то в коде называть как автомобиль (может
* быть где-то будет реализована функция, которая написана так, что она принимает объект автомобиля, а туда мы
* сможем запихивать любой объект придуманного нами класса реализующего интерфейс автомобиля)
*
* В целом интерфейсы нужны как прокладки, потому что есть непосредственное описание интерфейса, а есть его реализации
* (impl) и реализации могут быть разными. Например у меня в приложении есть необходимость хранить информацию. Я могу
* её хранить в базе данных (room), в локальном хранилище DataStorage или в облаке через API данного облака и я могу
* 3 реализации одного и того же интерфейса.
* */


/*9 Не знаю что такое launch, и не до конца понимаю зачем первым символом в имени переменной ставят знак нижнего
* подчеркивания*/

/*10 Не напишу, но кажется понимаю, что речь идет о запечатанном классе, как возможности описывать какой-то ограниченный
* объем состояний*/






















