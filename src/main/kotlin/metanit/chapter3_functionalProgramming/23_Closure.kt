package edu.cesspool.metanit.chapter3_functionalProgramming

import edu.cesspool.metanit.chapter2_basics.wrap

// -----------------------------------------------------------------
//                                                                 -
//                        З А М Ы К А Н И Я                        -
//                                                                 -
// -----------------------------------------------------------------


fun main(){
    wrap("EX 1"){closureExample()}
    wrap("EX 2"){closureEx2()}
}

/** В целом замыкание - это объект функции,
 * который запоминает свое лексическое окружение, даже в случае,
 * когда она выполняется вне своей области видимости.
 *
 * Пример ниже это демонстрирует на примере переменной n
 * */
fun closureExample(){
    val fn = outer()
    fn()                // изменяется вне зоны своей видимости (2)
    fn()
    fn()
}

fun outer(): () -> Unit {
    var n = 5           // локальная переменная (1)

    fun inner(){
        n++
        println("n = $n")
    }

    return ::inner
}
/**В нашем случае:
 * лексическое окружение - переменная n*/


//----------------------------------------------------------------
//      Е Щ Е    О Д И Н    П Р И М Е Р    З А М Ы К А Н И Я     -
//----------------------------------------------------------------

fun closureEx2(){
    val multOn5 = multiply(5)
    val multOn7 = multiply(7)

    println("5 * 8 = ${multOn5(8)}")
    println("7 * 57 = ${multOn7(57)}")
}

fun multiply(a: Int) : (Int) -> Int {
    return {b : Int -> a * b}
}

/** В данном примере наша лямбда, которую возвращает multiply
 * запоминает не свою переменную (параметр) a и использует его в работе*/





