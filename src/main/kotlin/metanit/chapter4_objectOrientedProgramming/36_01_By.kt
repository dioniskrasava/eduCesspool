package edu.cesspool.metanit.chapter4_objectOrientedProgramming.less36_01
/** ДЕЛЕГИРОВАНИЕ */

interface Seller {
    fun sell(item: String)
}

class RealSeller : Seller {
    override fun sell(item: String){
        println("Продаем $item за 100 рублей!")
    }
}

class CoolSeller : Seller {
    override fun sell(item: String) {
        println("Ахуенно продаем $item, да еще и за 200 рублей!")
    }
}

//----------------------------------------------------------------------------------
/** БЕЗ ДЕЛЕГИРОВАНИЯ
 *
 * директору нужно самому научиться продавать
*/
class DirectorWithoutDelegation : Seller {
    override fun sell(item: String) {
        // он не умеет продавать, но вынужден реализовывать этот метод
        println("Эээ... купите $item пожалуйста...")
    }
}
//-----------------------------------------------------------------------------------

class Director(var seller: Seller) : Seller by seller{
   /** Директор может не переопределять методы объекта-делегата
    *
    * В нашем случае мы переопределяем метод делегата - вызывая его и добавляя что-то своё */
    override fun sell(item: String) {
        seller.sell(item)
        println("Спасибо за покупку от директора!")
    }
}

/**
 * Директор реализует интерфейс Seller не сам, а с помощью объекта, который в себя примет в качестве собственного поля.
 * (его еще называют делегатом)
 *
 *
 * Зачем это нужно:
 *
 * 1. Уменьшение кода (не нужно переписывать методы которые уже есть у делегата)
 *
 * 2. Гибкость (Директор может делегировать разным продавцам разные задачи)
 *
 * 3. Композиция вместо наследования (это ключевой принцип ООП (который мне до сих пор непонятен))
 *
 *
 * КОГДА ИСПОЛЬЗОВАТЬ ДЕЛЕГИРОВАНИЕ:
 *
 * - Когда нужно работать с разными реализациями одного интерфейса (как в нашем примере, директор поработал с
 * обычным продавцом, а потом с крутым продавцом)
 *
 * - Когда базовый класс final (нельзя наследовать) - (если бы например класс RealSeller и CoolSeller были final - то
 * мы бы не смогли наследоваится от них, но могли бы взять как делегатов)
 *
 * - Когда нужно реализовать несколько интерфейсов
 *
 * - Когда нужно НЕМНОГО ДОПОЛНИТЬ существующую функциональность
 *
 * - Когда следуешь принципу "композиция предпочтительнее наследования"
 *
 * */
fun exBy() {
    val seller01 = RealSeller() // обычный продавец
    val seller02 = CoolSeller() // крутой продавец

    /**Почему бы не иметь двух директоров*/
    val director01 = Director(seller01)
    director01.sell("кубик-рубика")

    director01.seller = seller02 // теперь другой пацанчик в подчинении
    director01.sell(("кубик-рубика-2"))

}

fun main(){
    exBy()
}
